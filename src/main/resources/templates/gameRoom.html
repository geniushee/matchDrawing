<!DOCTYPE html>
<html lang="ko" layout:decorate="~{global/layout}" xmlns:layout="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameRoom</title>
    <script src="https://cdn.jsdelivr.net/npm/fabric@6.4.3/dist/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <!--stompJS 버전을 변경함-->
    <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@5.0.0/bundles/stomp.umd.min.js"></script>
    <script th:src="@{/js/QueueList.js}"></script>
</head>

<body layout:fragment="content">
    <article id="answer1" style="display: none; color: red;">
        <div id="answer2" style=" font-weight: 800; font-size: xx-large;">
        </div>
        <div id="answer3" style=" font-weight: 800; font-size: large;">
        </div>
    </article>
    <main style="display: flex;">
        <section id="loading">
            Loading...
        </section>
        <section id="main" style="display: none;">
            <!-- 그리는 사람 제외 비활성화 필요 -->
            <section id="tools" style="border : 1px solid; padding: 5px; max-width: 20%">
                <div style="margin-left: 5px; margin-bottom: 10px;">
                    <button id="pencil">pencil</button>
                    <button id="eraser">eraser</button>
                    <button id="clearBt">clear</button>
                </div>
                <section style="margin: 5px">
                    <div>pencil options</div>
                    <p>
                        <label for="colorPick">color : </label>
                        <input type="color" value="#000000" id="colorPick">
                    </p>
                    <p>
                        <label for="widthPick">width : </label>
                        <input style="width: 5em;" type="number" value="5" id="widthPick">
                    </p>
                    <p>
                        <button id="pencilDefault">기본 연필</button>
                    </p>
                </section>
            </section>
            <!--캔버스-->
            <canvas id="canvas" style="margin-left: 10px; border : solid" width="300" height="300"></canvas>
            <section style="display: flex; flex-direction: column; margin: 5px">
                <section id="playerList">
                    <ul>
                        <li th:each="mem, info :${roomDto.curMember}">
                            <span th:id="|${mem.username}_score|"></span><span th:text="${mem.username}"></span>
                        </li>
                    </ul>

                </section>
                <section id="msgBox">
                    <div>
                        채팅창
                    </div>
                    <hr>
                </section>
                <hr>
                <form id="msgForm" th:action method="POST">
                    <input id="send" name="send" type="text"> <button type="submit">보내기</button>
                </form>
            </section>
        </section>
    </main>

    <script th:inline="javascript">

        const username = /*[[${@rq.getUsername()}]]*/ 'noUser';
        const roomInfo = /*[[${ roomDto }]]*/ { id: null };
        const roomId = roomInfo.id;

        // 방장과 참여자를 구분하기 위한 메소드. 캔버스를 나누어 구현할 필요가 있음.
        function isOwner(_username) {
            if (_username === roomInfo.owner.username) {
                return true;
            }
            return false;
        }

        // 로딩 구현
        document.addEventListener("DOMContentLoaded", function () {
            const loadingSection = document.getElementById("loading")
            const mainSection = document.getElementById("main")

            //초기화
            loadingSection.style.display = "block";
            mainSection.style.display = "none"
            enterGame()

            async function isLoading() {
                const url = "http://localhost:8080/api/game/isLoading?roomId=" + roomId;
                const response = await fetch(url);

                if (!response.ok) {
                    return false;
                }

                const data = await response.json();
                console.log(data);
                return data;

            }

            async function enterGame() {
                const url = "http://localhost:8080/api/game/enterGame";
                const response = await fetch(url, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        roomId: roomId,
                        username: username,
                    })
                });
            }

            async function checkLoadingComplete() {
                const isLoaded = await isLoading();
                if (isLoaded) {
                    loadingSection.style.display = "none";
                    mainSection.style.display = "flex"

                    clearInterval(interval) //반복 중단
                } else {
                    console.log("loading....")
                }
            }

            var interval = setInterval(checkLoadingComplete, 1000)
        })

        // 정답 큐 생성
        const answers = new window.QueueList();
        answers.enqueue("보자기")
        answers.enqueue("바위")
        answers.enqueue("가위")

        // 캔버스 초기화
        const canvas = new fabric.Canvas('canvas')
        // 방장 여부에 따른 캔버스 구분
        if (isOwner(username)) {
            canvas.isDrawingMode = true;
        }
        console.log(canvas);

        SockJS.prototype.debug = true;
        // websocket 및 stomp 연결부분
        const socket_dr = new SockJS('http://localhost:8080/dr',{},{});

        // stompJs 버전 변경
        // const stompClient_dr = Stomp.over(socket_dr);

        // stompJs 버전 변경 후
        const stompClient_dr = new StompJs.Client({
            webSocketFactory: () => socket_dr,
            debug: function (str) {
                console.log(str);
            }
        });

        // stompClient onConnect 변경 - StompJs버전 변경 후
        stompClient_dr.onConnect = function (frame) {
            // console.log("Connected: " + frame) debug 옵션을 사용하며 불필요해짐
            if (!isOwner(username)) {
                stompClient_dr.subscribe(`/topic/drawing${roomId}`, function (data) {
                    let jsonData = JSON.parse(data.body)

                    // 클리어 메소드 동기화
                    if (typeof jsonData.msg === 'string' & jsonData.msg.includes("method")) {
                        let methodName = jsonData.msg.split(":")[1];
                        if (methodName === "clear") {
                            canvas.clear()
                        }
                    } else {
                        console.log(`${jsonData.sender} : ${jsonData.msg}`)
                        const data = JSON.parse(jsonData.msg);
                        fabric.Path.fromObject(data)
                            .then((path) => {
                                console.log(path)
                                canvas.add(path)
                            })
                        // canvas.loadFromJSON(jsonData.msg).then((canvas) => canvas.requstRenderAll())
                    }
                })
            }
        }

        console.log(stompClient_dr);

        // stompJS 버전 변경으로 삭제
        // stompClient_dr.debug = (msg) => {
        //     console.log('[STOMP dr_client Debug]:', msg)
        // }

        const socket_msg = new SockJS('http://localhost:8080/ws?roomId=' + `${roomId}`);
        const stompClient_msg = new StompJs.Client({
            webSocketFactory: () => socket_msg,
            debug: function (str) {
                console.log(str);
            }
        }) // connectHeaders에 직접 로그인 정보를 입력할 수 있음. 차후 검토.

        // stompClient onConnect 변경 - StompJs버전 변경 후
        stompClient_msg.onConnect = function (frame) {
            // console.log("Connected: " + frame) debug 옵션을 사용하면서 불필요해짐
            stompClient_msg.subscribe(`/topic/room${roomId}`, function (data) {
                let jsonData = JSON.parse(data.body)

                if (jsonData.sender === "break") {
                    // 방장이 나갔다는 메세지 출력
                    alert(jsonData.msg);
                    // alert가 종료되면 자동으로 리디렉션
                    window.location.href = "http://localhost:8080/roby/list";
                }

                if (!isOwner(jsonData.sender)) {
                    if (jsonData.msg.includes(answers.first())) {
                        showAnswer(jsonData.sender, answers.dequeue());
                    }
                }

                let msgBox = document.getElementById('msgBox');
                let msgBit = document.createElement("div");
                msgBit.innerHTML = `${jsonData.sender} : ${jsonData.msg}`
                msgBox.appendChild(msgBit);
            })
        }

        //StompJs 버전 변경으로 추가
        stompClient_dr.activate();
        stompClient_msg.activate();


        // stompJS 버전 변경으로 삭제
        // const stompClient_msg = Stomp.over(socket_msg);
        // stompClient_msg.debug = (msg) => {
        //     console.log('[STOMP msg_client Debug]:', msg)
        // }

        // stompJs 버전 변경으로 삭제
        // 캔버스 - 오너가 아닌 경우에만 서브스크라이브
        // stompClient_dr.connect({}, function (frame) {
        //     // console.log("Connected: " + frame) debug 옵션을 사용하며 불필요해짐
        //     if (!isOwner(username)) {
        //         stompClient_dr.subscribe(`/topic/drawing${roomId}`, function (data) {
        //             let jsonData = JSON.parse(data.body)

        //             // 클리어 메소드 동기화
        //             if (typeof jsonData.msg === 'string' & jsonData.msg.includes("method")) {
        //                 let methodName = jsonData.msg.split(":")[1];
        //                 if (methodName === "clear") {
        //                     canvas.clear()
        //                 }
        //             } else {
        //                 console.log(`${jsonData.sender} : ${jsonData.msg}`)
        //                 const data = JSON.parse(jsonData.msg);
        //                 fabric.Path.fromObject(data)
        //                     .then((path) => {
        //                         console.log(path)
        //                         canvas.add(path)
        //                     })
        //                 // canvas.loadFromJSON(jsonData.msg).then((canvas) => canvas.requstRenderAll())
        //             }
        //         })
        //     }
        // });

        // StompJs 버전 변경으로 삭제
        // 채팅
        // stompClient_msg.connect({}, function (frame) {
        //     // console.log("Connected: " + frame) debug 옵션을 사용하면서 불필요해짐
        //     stompClient_msg.subscribe(`/topic/room${roomId}`, function (data) {
        //         let jsonData = JSON.parse(data.body)

        //         if (jsonData.sender === "break") {
        //             // 방장이 나갔다는 메세지 출력
        //             alert(jsonData.msg);
        //             // alert가 종료되면 자동으로 리디렉션
        //             window.location.href = "http://localhost:8080/roby/list";
        //         }

        //         if (!isOwner(jsonData.sender)) {
        //             if (jsonData.msg.includes(answers.first())) {
        //                 showAnswer(jsonData.sender, answers.dequeue());
        //             }
        //         }

        //         let msgBox = document.getElementById('msgBox');
        //         let msgBit = document.createElement("div");
        //         msgBit.innerHTML = `${jsonData.sender} : ${jsonData.msg}`
        //         msgBox.appendChild(msgBit);
        //     })
        // });

        // 방장만 그리기 도구가 보이도록
        document.addEventListener('DOMContentLoaded', function () {
            const tools = document.getElementById('tools');
            if (isOwner(username)) {
                tools.style.display = 'block';
            } else {
                tools.style.display = 'none';
            }
        });

        // 캔버스 기능 시작
        var $ = function (id) { return document.getElementById(id); }

        var eraser = $("eraser"),
            pencil = $('pencil'),
            pencilColor = $('colorPick'),
            pencilWidth = $('widthPick'),
            clear = $('clearBt');


        // 방장 여부에 따른 캔버스 기능 구분
        if (isOwner(username)) {
            canvas.freeDrawingBrush = new fabric['PencilBrush'](canvas);
            canvas.freeDrawingBrush.color = pencilColor.value;
            canvas.freeDrawingBrush.width = parseInt(pencilWidth.value, 10) || 1;

            // 그림이 그려질 때마다 데이터 생성 - 그림이 일정이상 그려지면 데이터의 크기가 Stomp에서 제한하는 크기 이상이 되어 연결이 끊김
            canvas.on("path:created", function (o) {
                console.log(o.path)

                // path를 데이터로 생성
                const pathData = JSON.stringify(o.path);
                console.log("path:created :: ", pathData);
                if (isUnderDataLimit(pathData)) {
                    // 그리기 공유, StompJs 버전 변경으로 수정
                    stompClient_dr.publish({
                        destination: `/app/drawing${roomId}`,
                        body: JSON.stringify({ msg: pathData })
                    })
                } else {
                    alert("조금 더 작게 그려주세요.");
                    canvas.discardActiveObject();
                    let sel = new fabric.ActiveSelection([JSON.parse(pathData)], {
                        canvas: canvas,
                    });
                    sel.removeAll();
                }

                // 그림 데이터 json으로 생성
                // var jsonData = JSON.stringify(canvas);
                // console.log("JSON : " + jsonData)

            })


            pencilColor.onchange = function () {
                canvas.freeDrawingBrush.color = this.value;
                canvas.freeDrawingBrush.width = pencilWidth.value;
            }

            pencilWidth.onchange = function () {
                canvas.freeDrawingBrush.color = pencilColor.value;
                canvas.freeDrawingBrush.width = parseInt(this.value, 10) || 1;
            }

            $('pencilDefault').onclick = function () {
                canvas.freeDrawingBrush.color = '#000000';
                canvas.freeDrawingBrush.width = 5;
            }

            eraser.onclick = function () {
                canvas.freeDrawingBrush.color = '#ffffff';
                canvas.freeDrawingBrush.width = 20;
            }

            pencil.onclick = function () {
                canvas.freeDrawingBrush.color = pencilColor.value;
                canvas.freeDrawingBrush.width = pencilWidth.value;
            }

            clear.onclick = function () {
                canvas.clear();

                // 그리기 공유, StompJs 버전 변경으로 수정
                stompClient_dr.publish({
                    destination : `/app/drawing${roomId}`,
                    body: JSON.stringify({ msg: "method:clear" })
                })
            }
        } else {
            // 새로운 캔버스에 옮겨지면 재렌더링
            canvas.on('object:added', function () {
                // 그리는 사람 제외 비활성화 필요
                // var objs = canvas.getObjects();
                // for(var i = 0, len = objs.length; i < len; i++){
                //     objs[i].selectable = false;
                // }
                canvas.renderAll();
            })
        }
        // 캔버스 기능 끝

        document.addEventListener("DOMContentLoaded", function () {
            const sendBt = document.getElementById("msgForm");
            sendBt.addEventListener("submit", function (event) {
                postMsg(event);
            })
        })

        function postMsg(event) {
            event.preventDefault();
            let sendMsg = document.getElementById('send');
            let msg = sendMsg.value.trim();
            // StompJs 버전 변경으로 수정
            stompClient_msg.publish({
                destination : `/app/room${roomId}`,
                body : JSON.stringify({ msg: msg })
            })
            console.log(msg);
            sendMsg.value = "";
        }

        function showAnswer(_username, _value) {
            const answerTxt = document.getElementById("answer1");
            const answerBit1 = document.getElementById("answer2");
            const answerBit2 = document.getElementById("answer3");

            answerBit1.innerHTML = `${_username} 정답!`
            answerBit2.innerHTML = `${_value}`

            scoreMap.set(_username, scoreMap.get(_username) + 1);
            const scoreLabel = document.getElementById(`${_username}_score`)
            scoreLabel.innerHTML = scoreMap.get(_username);

            answerTxt.style.display = "block";

            setTimeout(function () {
                answerTxt.style.display = "none";
                answerBit1.innerHTML = "";
                answerBit2.innerHTML = "";
            }, 3000);
        }

        //점수판
        const scoreMap = new Map();
        for (const member of roomInfo.curMember) {
            if (!isOwner(member.username)) {
                scoreMap.set(member.username, 0)
            }
        }

        function isUnderDataLimit(str) {
            const encoder = new TextEncoder();
            const length = encoder.encode(str).length;
            console.log("length < 64 * 1024???", length < 15 * 1024, "length : ", length)
            return length < 15 * 1024;
        }

    </script>
</body>

</html>